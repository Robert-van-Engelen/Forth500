        Absolute type cross assembler for CPU-SC62015
                    (English Translation)

                       XASM [VER 1.2x]

On a machine with a small storage capacity such as the current pocket computer,
the use of machine language is indispensable to create a program that can
withstand use to some extent. However, it is not always effective from the
viewpoint of the development environment to develop it only with the pocket
computer itself.

In that respect, the development environment of personal computers has become
able to withstand a certain degree of use, although it is far from that of
workstations, and the penetration of machines has reached a satisfactory level,
as can be said.

Therefore, this time, for many pocket computer users who can use a good
development environment, I created a "cross assembler" that enables the
development of pocket computer machine language on a general-purpose MS-DOS
machine.

-1. Features of XASM [VER 1.2x]-

XASM [VER1.2x] (hereinafter simply referred to as "XASM") is an assembler
for "SC-62015", which is a CPU listed in Sharp's pocket computer.  A cross
assembler for assembling a system program on a general-purpose MS-DOS machine.

The main features of this assembler are as follows.

(1) The assembler is the source of the "prebyte" required for addressing the
internal RAM. Equipped with a "pre-byte automatic generation function" that
interprets the program and automatically generates it. Of course, this can be
disabled for compatibility with other assembler sources.

(2) "Local" that can nest up to 16 steps by using LOCAL and ENDL
pseudo-instructions. Since "label" can be used, it is easy to give a
"meaningful" label name.

(3) Macro expansion by using the file include instruction "INCLUDE" with
arguments. It is possible to describe open-like sources. Files can be included
in any number of stages.

(4) The listing file when an error occurs is a tag file with an editor such as
MIFES can be used.

(5) Five types of objects can be output by specifying options.

(6) Objects generated by using in combination with the separately announced
"Pocket Link System". It is possible to configure a system that can transfer
and test the data to a pocket computer very easily and at high speed.

-2. How to write a source program-

The source program must be written according to the following format.

-2.1 File specifications-

It consists of one statement per line, and the final statement must end with an
END pseudo-instruction.

-2.2 Statement specifications-

Each statement must satisfy the following syntax diagram.

    -statement- 

    +--------------------->-----------------------+ 
    |                                             | 
  --+->- [label] ->- ":" ->-+->- [instruction] ->-+->- [comment] --+--
    |                       |                     |                |
    +->- [space] ----->-----+----------->---------+------->--------+  

    -instruction- 
                      +------------->-----------+ 
                      |                         | 
  -->-- [mnemonic] ->-+->-+->- [operand] ->-+->-+->-
                          |                 | 
                          +---<---","---<---+ 

    -mnemonic-

  -->--+------->-------+->- mnemonic ->-+-------->------+->-
       |               |                |               | 
       +->- [space] ->-+                +->- [space] ->-+ 

    -operand- 

  -->--+------->-------+->-  operand ->-+-------->------+->-
       |               |                |               | 
       +->- [space] ->-+                +->- [space] ->-+ 

    -space- 

  -->--+->- " " or TAB ->-+->-  
       |                  | 
       +---------<--------+ 


    -comment- 

  -->- ";" ->-+---->----+->-
              |         |             ? is a one-character wild card
              +-<- ? -<-+ 

-2.3 Label specifications-

A to z, A to Z, 0 to 9, "_ (underscore)" can be used as the characters that
make up the label, but uppercase and lowercase letters are treated as the same
thing. Also, 0-9 cannot be used as the label start character.

The maximum length of the label is 16 characters. If it exceeds 16 characters,
an error will occur.

You can create a label with the same name as the reserved word, and in
principle you can refer to it, but some commands may not be able to refer to
it. Therefore, it is wise to avoid using such labels as much as possible.

Labels cannot be redefined.

-2.4 Operand specifications-

Numbers, character constants, labels, location counters, and include arguments
can be used for operands (including file names for some pseudo-instructions),
and they can also be calculated using operators. The numerical value is
sequentially converted to a 20-bits unsigned integer even in the middle of the
expression, and is referenced from the lower level by the number of bytes
required by the instruction.

* Numbers
0-9, a to f, A to F can be used. However, the number constituent characters
must start with 0-9 or "$" (only for hexadecimal numbers).

The default is a decimal number, but you can change the radix by adding a
specific character at the end. However, in the case of n-ary numbers, the
constituent characters must not exceed (n-1).

The relationship between the last letter and the radix is as follows.

  B, b     binary
  O, o     octal
  D, d     decimal
  H, h     hexadecimal

Also, in order to make it easier to see when there are many digits,
"_ (underscore)" can be inserted at any position.

(Example) 0100_1100b ... $4C

* Character constant
Of the characters enclosed in "'(single quote)", the character code of the one
character closest to the "'" on the right is treated as a numerical value. Null
code can be written as "", and single quotes themselves can be written by
writing two single quotes in a row.

(Example) 'ABCD'     $44 ("D" code)
          ''''       $27 (single quote code)
          '  '       $20 (space code)
          ''         $00 (null code)

* Location counter
The location counter (LC) is represented by "*" and has the address where the
instruction currently being assembled should be placed as a value. The location
counter and multiplication symbol use the same "*", but the expression
evaluation routine makes a contextual judgment, so even if they are confused,
they will be evaluated correctly.

(Example) -1 *-* + *     Evaluated as "minus 1 times minus LC plus LC"

* Include arguments
Only in the include file, you can refer to the argument passed by the INCLUDE
pseudo instruction by adding a number from 0 to 9 after "@ (at sign)".

The first argument corresponds to "@0", and the following "@1", "@2" ... are
the second argument, the third argument ..., respectively.

An error will occur if the file currently being assembled is not an included
file, there are no arguments in the INCLUDE pseudo-instruction, or if more
arguments are referenced than the number passed.

* Operator
Operators are "| (logical sum)", "& (logical product)", "% (residual)",
"+ (addition)", "-(subtraction)", "* (multiplication)", "/ (Division) " can be
used, and the priority is

  "|" < "&" < "%" < "+", "-" < "*", "/"

You can use "(" and ")" to change the priority, but the right and left
parentheses must correspond.

When "+" and "-" are added at the beginning of an expression or after an
operator, they mean a sign and are processed with the highest priority.

-2.5 Instructions-

You can assemble all the instructions that SC62015 has. It should be noted that
instructions such as "mv a, x" that are prohibited in the genuine instruction
table but can actually be used can also be assembled, so if there is
information such as CPU design changes in the future, instructions will be
issued. Pay close attention to the relevant information.

PUSHS r and POPS r are expanded by the equivalent mv instruction.

The pseudo instructions that can be used to control assembly are as follows.
Note that [...] in the format indicates that ... can be omitted, and [...]*
indicates that ... is repeated 0 or more times.

* ORG
Format: ORG operand
Determine the start address of the object to be expanded from the next.  Note
that an error will occur if operator is undefined at the time of assembly.
Also, if ORG appears more than once in a series of source programs, it will be
processed as follows according to the value.

  - If you try to set to a past address an error will occur.
  - If you try to set it to a future address a warning will be issued to
    forcibly rewrite the location counter.

* END
Format: END
Indicates the end of the source program or the end of the include file. If the
correspondence between LOCAL and ENDL is not established when this instruction
is assembled, an error will occur.

* EQU
Format: label: EQU operand
Assign a value to the label. Even if the operand is undecided at the time of
assembly, no error will occur if it is determined in some way by the end of
assembly. However, if the label definitions are circular or inconsistent, an
error will occur.

(Example) label1: EQU label2     Error, neither label1 nor label2 is defined
          Label2: EQU label1
          Label3: EQU label3 + 2 Inconsistent definitions are errors

Also, if there is no label at the beginning, an error will occur.

* DB, DM
Format: DB (DM) operand [, operator]*
Expand the lower 1 byte of the operand. Multiple operands can be described by
separating them with ", (comma)". In addition, the following format is valid
only in the operands of DB, DM, DW, and DP.

Format: 'c...c'

Function: Expands the character string between "'" as a character code for each
byte. The "'" itself can be described by writing two "'" in a row.

(Example) 'I don''t know'
          $49, $20, $64, $6F, $6E, $27, $74, $20, $6B, $6E, $6F, $77

* DW
Format: DW operand [, operator]*
Expands the lower 2 bytes of the operand in the order of lower and upper.
Others are based on DB and DM.

* DP
Format: DP operand [, operator]*
Expand operand over 3 bytes in the order of lower, middle, and upper (4 bits).
The upper 4 bits of the upper 1 byte are always 0. Others are based on DB and
DM.

* DS
Format: DS operand1 [, operator2]
Reserve the number of bytes indicated by operator1. If operand2 also exists,
the allocated memory area is filled with the lower 1 byte of operator2.

* PRE
Format: PRE operand
The value indicated by operand is regarded as the prebyte itself and expanded
by 1 byte. However, if operand is not $21 or more and $27 or less, or $30 or
more and $37 or less, an error will occur. Also, if you use this instruction
when the automatic prebyte generation function is enabled, a warning will be
issued.

* PRE_ON
Format: PRE_ON
Enable the prebyte automatic generation function for the following source
programs. The default is PRE_OFF.

* PRE_OFF
Format: PRE_OFF
Disable the prebyte automatic generation function for the subsequent source
programs.

* LOCAL
Format: label: LOCAL
After using label as the entry label, declare up to ENDL as a local block.
Nesting such as declaring a local block in a local block is also possible.
However, if label does not exist, an error will occur. For details, refer to
"About Hierarchical Labels" below.

* ENDL
Format: ENDL
Declare the end of the local block. An error will occur if the local block has
not been declared first.

* INCLUDE
Format: INCLUDE filename [, argument]*
When this command is assembled, the file specified by filename is opened and
the file is assembled. When the file is finished, the assembly will resume from
the continuation of the original file. Nesting such as using the INCLUDE
instruction from the included file is also possible.

Also, if arguments exist after filename, they can be passed as arguments to the
included file, and they can be referred to as "@0" to "@9" in the included
file. However, up to 10 arguments are allowed.

-3. Assembling method-

To assemble

  A> XASM filename[.ext]

will do. If filename is omitted, a brief guidance will be displayed and you
will be returned to the command level. If the extension of the source file name
is ".ASM", the extension may be omitted.

When the assembly is started, the current processing stage is displayed as
[PASS1] and [PASS2], and when the assembly is completed normally, the start
address, end address, and object size of the object are displayed at the
command level. Return to. If the label defined by the EQU instruction is
referenced before it is defined, the path for label definition ([EQU define])
is inserted between [PASS1] and [PASS2].

If an error occurs during assembly, the file name where the error occurred, the
line number where the error occurred, and the type of error are displayed on
the display. Also, if the output of the listing file is specified, the same
information will be output to the listing file.

By the way, XASM does not output anything as a file just by assembling it by
simply using XASM filename. You need to specify some options to output the
object file or the listing file.

The options provided by XASM are as follows.

* L
Format: -L[filename]
Specify to output the listing file. If filename is not specified, the
extension, ".LST", will be added to the primary of the source file.

* E
Format: -E
Suppress the object part in the listing file and specify to leave only the
error part. If an error is likely to occur at the stage of PASS2 and you want
to use the listing file as a tag file for the editor, you should specify this
option at the same time as the L option. If the L option is not specified, it
will be invalid.

* O
Format: -O[filename]
Specify to output the object file. If filename is not specified, the extension
and ".OBJ" will be added to the primary of the source file.

* S
Format: -S
Specify to add the label used at the end of the listing file and a list of its
values. However, if the L option is not specified, it will be invalid.

* C
Format: -C
Specify to display the line number currently being processed on the display
during assembly. You may want to specify it when you are assembling a long file
and you are worried about how far the processing has been completed.

* T
Format: -T[object type]
Specify the format of the object file. The correspondence between object type
and format is as follows.

  object type
      Z        Specify an object in ZSH format.
      F        Specify an object in FTX format.
      B        Specify an object in binary data format. What is the binary
               data format? It refers to an object consisting of object_size
               (3 bytes) + start_address (3 bytes) + object_body (n bytes).
      H        Specify an object in hexadecimal format. Hexadecimal format is a
               binary data format data converted to a hexadecimal 2-digit
               2-byte character with a line feed code inserted every 64
               characters.
    other      In front of the other object body, specify the object of the
               device with a header (16 bytes) that contains the information
               necessary for handling as a machine language file by the IOCS of
               the pocket computer.

If you do not specify the object type, other is automatically specified.

* W
Format: -W
Specify to generate a warning.

To use the option

  A> XASM filename -option [-option]*

Option names are treated equally in both case.

(Example) A> XASM TEST -L -OTEST1.FTX -S -TF -W
          Create a listing file with the name TEST.LST, create an object file
          with the name TEST1.FTX, create a symbol list, specify the object
          format as FTX format, and a warning will also occur.

-4. About layered labels-

What made me happy when I moved from CP/M to MS-DOS was what I was most happy
about. But wasn't it a hierarchical directory?

Until now, I had to put everything in root, and I couldn't organize it because
I could organize it neatly by creating a directory for each related item and
throwing it in there. In addition, you can create additional subdirectories in
the directory, and files with the same name can exist on the same disk if the
directories are different, so the environment provided by the hierarchical
directory is very convenient.

By the way, consider the label management of the current absolute assembler.

The most important thing in writing the assembler source is "label naming",
isn't it?

A label is attached to the branch instruction. You must use at least one label
to make one small loop. Every time, "Well, I've already used label09, is it
label0a next?", And I have to waste effort in a place completely different from
the original purpose. Moreover, when I look at it later, I have no idea what
label09 means or what label0a means unless I write a comment.  Therefore, in
order to free my mind from such a "label naming problem", I tried to introduce
the concept of "hierarchical label" experimentally this time. The idea is UNIX,
MS-DOS

It's very similar to the layered file structure, so it's easy to understand.

First of all, it corresponds to a subdirectory, but in this assembler system,
this is called a local block. To define a local block, just use the
pseudo-instructions "LOCAL" and "ENDL" in pairs.

For example, look at the 2nd to 6th lines of the sample. In this way, the area
between LOCAL and ENDL will be a local block named "ABC".

You can also create a local block inside the local block, so you can write it
like the 7th to 20th lines of the sample.

Since the inside of the local block is similar to the subdirectory, it does not
matter if there is a label with the same name outside the block (2nd and 12th
lines of the sample). Therefore, we will call the label in the local block the
local label.

Well, even if a local block or local label is created, it doesn't mean anything
unless it can be specified by the operand.

Therefore, this time it is a label specification method, but this is very
different from that of UNIX and MS-DOS.  similar. The format is as follows.

(1) Only the label name is required for the label in the same block (5th line
of the sample).

(2) When specifying the label in the local block in the block where you are

  [block name!]* label name

(9th line of the sample).

(3) To specify a label outside the block you are in

  .. !label name

(14th line of the sample). Note that ".." is one outside (= immediately
outside), but "..." is two outside, "...." is three outside, and so on.

(4) When following in order from the outermost block

  ! [block name!]* label name

(Line 11 of the sample).

(5) To specify a label in a block different from the one you are in

  . [.]* ! [block name!]* label name

(Line 25 of the sample). Alternatively, it may be specified directly as in (4).

------------------------------------------------------------------------------
  -SAMPLE.ASM-
        org     $bf800                  ;1
abc:    local                           ;2
        mv      a,0                     ;3
l1:     inc     a                       ;4
        jrnz    l1                      ;5
        endl                            ;6
def:    local                           ;7
        mv      a,0                     ;8
        callf   abc!l2                  ;9
l3:     add     ($10),a                 ;10 
        jpf     !ghi!abc!abc!l4         ;11 
abc:    local                           ;12 
        mv      a,0                     ;13 
        mv      x,..!l3                 ;14 
        add     ($10),a                 ;15 
l2:     retf                            ;16 
l5:     nop                             ;17 
        endl                            ;18 
        nop                             ;19 
        endl                            ;20 
ghi:    local                           ;21 
abc:    local                           ;22 
abc:    local                           ;23 
l4:     nop                             ;24 
        mv      x,....!def!abc!l5       ;25 
        endl                            ;26 
        endl                            ;27 
        endl                            ;28 
        end                             ;29 

  -SAMPLE.LST-
0BF800                          org     $bf800
0BF800                   abc:   local 
0BF800 08 00                    mv      a,0 
0BF802 6C 00             l1:    inc     a 
0BF804 1B 04                    jrnz    l1
0BF806                          endl
0BF806                   def:   local 
0BF806 08 00                    mv      a,0 
0BF808 05 1A F8 0B              callf   abc!l2
0BF80C 43 10             l3:    add     ($10),a 
0BF80E 03 1D F8 0B              jpf     !ghi!abc!abc!l4 
0BF812                   abc:   local 
0BF812 08 00                    mv      a,0 
0BF814 0C 0C F8 0B              mv      x,..!l3 
0BF818 43 10                    add     ($10),a 
0BF81A 07                l2:    retf
0BF81B 00                l5:    nop 
0BF81C                          endl
0BF81C 00                       nop 
0BF81D                          endl
0BF81D                   ghi:   local 
0BF81D                   abc:   local 
0BF81D                   abc:   local 
0BF81D 00                l4:    nop 
0BF81E 0C 1B F8 0B              mv      x,....!def!abc!l5 
0BF822                          endl
0BF822                          endl
0BF822                          endl
0BF822                          end 

 - Symbols -

0BF800 : ABC
0BF802 : ABC ! L1 
0BF806 : DEF
0BF80C : DEF ! L3 
0BF812 : DEF ! ABC
0BF81A : DEF ! ABC ! L2 
0BF81B : DEF ! ABC ! L5 
0BF81D : GHI
0BF81D : GHI ! ABC
0BF81D : GHI ! ABC ! ABC
0BF81D : GHI ! ABC ! ABC ! L4 

  No fatal error.  Code: 0BF800h - 0BF821h [       34 byte(s)]
------------------------------------------------------------------------------

In the above, the block name and label name are written separately, but since
they are not distinguished internally, it is perfectly okay to use the block
name as an operand as a label.

The above is the outline and usage of the layered label, but it may be a little
difficult to use because it is still young. However, I think that it will be
useful when writing source programs with functional differentiation or
library-like programming using INCLUDE pseudo-instructions, so please make
effective use of it.

-5. List of errors and warnings-

XASM will issue an error or warning if it finds any inadequacies in the source
code during assembly. Below is a list of the error & warning messages and their
contents.

-5.1 Error related to source code-

* Prebyte error
Prebyte specification is incorrect (mv (bp + py), 0, etc.)

* Division by zero
Attempt to divide by 0

* Operator error
There are symbols that are not appropriate as operators, or operators that are
not expected.

* Une value table operand
Cannot be evaluated because the format of the operand is incorrect.

* Bad internal RAM addressing
The expression or reference method of the internal RAM is strange.

* Bad external MEMORY addressing
The representation or reference method of the external memory is strange.

* Undefined instruction
Attempt to execute a combination of non-existent instructions or non-existent
operands

* Bad separator
Inappropriate delimiter is used as delimiter, or there is no necessary
delimiter

* Branch too far
The branch destination is too far to branch with a relative branch instruction

* Label format error
The format is strange as a label

* Label not found
The specified label is undefined

* Duplicate label
Attempted to define two or more labels with the same name in the same block

* "LOCAL" not closed
There is no ENDL corresponding to LOCAL

* No label before EQU
There is no label before EQU in the same statement

* LOCAL nesting too deep
LOCAL nesting is too deep (up to 16 steps)

* ENDL used without LOCAL
There is no LOCAL corresponding to ENDL

* EOF comes before END
The file was closed before END came.

*'unmatch
The correspondence of "'(single quote)" is strange.

* No label before LOCAL
There is no label before LOCAL in the same statement

* Missing operand
The required operand does not exist

* Missing operator
The required operator does not exist

* Numeric format error
Numerical expression is strange

* Missing numeric
The required number does not exist

* Too complex operand
Operand expression expression is too complicated

* Location counter wandered
The value of the location counter became indefinite

* EQU undefinable (suspicious label is "xxxxxx")
The label definition is circular or an inconsistent label definition is
attempted. The suspicious label is xxxxxx

* Too many arguments
There are too many arguments in INCLUDE (maximum 10)

* Bad argument number
Attempt to refer to an undefined INCLUDE argument

-5.2 Warning about source code-

* Warning: Location counter already set
Warning that redefining the location counter may cause an inconsistency in the
address of the object.

* Warning: Used PRE while auto-prebyte is active
Warning for trying to generate useless prebytes even though the prebyte
automatic generation function is effective

* Warning: No effective code
Warning that there is an instruction that does not affect the object even if it
is assembled

* Warning: LOCAL and ENDL not match in included file
Warning that the local block is not closed in the included file and the
structure is incomplete, assuming the source code is made into a library.

-5.3 Error related to file input/output-

* Source file not found
Source file not found

* Source file not open
Cannot open the specified source file

* Output file not open
Cannot open the file for output

* Operation not allowed on a logical device
Attempted to gain unauthorized access to a logical device

* Assign to STD files not allowed
Cannot be assigned to a standard device

* Unexpected EOF
Unexpectedly, the file came to physical termination

* Disk write error
Output to a file became impossible for some reason

* Directory is full
Cannot secure the required directory

* File size overflow
File size is too large

* Too many open files
Too many files are open

* File disappeared
The file has disappeared

* Some error happend
I/O errors other than the above

-6. Precautions for use-

* We have not checked the use of recursive INCLUDE instructions, so such a
source code If you write and assemble the file, an I / O error of "Too many
open files" will appear and the assembly will be stopped.

* The ": (colon)" after the label cannot be omitted even before the EQU
instruction. About this I think there are various opinions, but I thought that
it was not necessary to take the colon, so I made it like this.

* If you reset the value of the location counter with the ORG instruction, the
object will be placed.  There may be a conflict between the address and the
operands such as the jump instruction. It is safer to reset the location
counter only if it is unavoidable due to label definition. After reconfiguring,
you should use the DS instruction instead of the ORG instruction if you want to
spit out any object.

(Example) ORG $BF000 -> DS $BF000-*

However, please note that it takes a very long time to assemble the DS
instruction if the number of operands is large.

* For relative branch instructions, the assembler determines from the values
of the operand and rotation counter.

You don't have to think about the branching direction because it automatically
expands the appropriate instructions.

* If unnecessary parentheses are added when describing the operand, the
assembler may refer to internal RAM depending on the instruction.  Assembling
may be interrupted by issuing "Undefined instruction" by mistake for RAM
addressing. Do not use unnecessary parentheses.

(Example) Wrong:   ADD ($10), ($20)     Error
          Correct: ADD ($10), $20       Assembled normally

* During assembly, the operand is undefined at that time and is an EQU
instruction in the future.  If there is a label defined by, the path will be
increased by one for the label definition, and it will take time to complete
the assembly. Therefore, it is wise to use the EQU instruction as much as
possible before its label is referenced in the operand.  Of course, if the
definitions are circular or inconsistent, an error will occur.

* Character constants are expanded with 1 byte per character even during DW and
DP instructions.

* If the assembly is completed normally, 0 is returned to "ERRORLEVEL" of
MS-DOS, and 1 is returned when an error occurs, so it may be convenient to use
it for batch programming.

-7. How do you feel about "XASM"?-

How is the usability of XASM?
It took one month to produce and three months or more to improve, and since it
was created with the advice of many people directly or through the BBS, it is
said that the design is quite satisfactory except for the assembly speed, I
think.

Finally, Mr. Takashi Ishioka who suggested that the listing file be in the tag
file format of the editor, Mr. E.Kako who cooperated in finding bugs and
creating sample programs at the development stage, JA1YAD stations, etc. We
would like to take this opportunity to thank all those who gave us their
advice.
