　　　　　アブソリュート・タイプ　クロスアセンブラ　for CPU-SC62015 

　　　　　　　　　　■■　ＸＡＳＭ［ＶＥＲ　１．２ｘ］　■■

　現在のポケコンのように記憶容量の小さいマシンに於いて、ある程度使用に耐え得るプログラムを作成するにはマシン語の使用が不可欠です。しかしながらポケコン本体のみでその開発を行なうということは、開発環境の面から見て必ずしも効果的であるとは言い難いものがあります。
　その点、パソコンの開発環境はワーク・ステーションのそれには到底及ばないもののある程度の使用には耐え得るようになってきており、またマシンの普及度に於いても申し分のないレベルまで到達しているといえるでしょう。
　そこで今回は、良い開発環境を利用できる多くのポケコンユーザーのために、汎用ＭＳ－ＤＯＳマシン上でポケコンのマシン語開発を行なうことを可能にする”クロスアセンブラ”を制作してみました。

　－１．　ＸＡＳＭ［ＶＥＲ　１．２ｘ］の特長－
　ＸＡＳＭ［ＶＥＲ１．２ｘ］（以下、単に”ＸＡＳＭ”と表記）は、シャープのポケコンに登載されているＣＰＵである「ＳＣ－６２０１５」を対象として書かれたアセンブラソースプログラムを汎用ＭＳ－ＤＯＳマシン上でアセンブルするためのクロスアセンブラです。
　このアセンブラの主な特長は次の通りです。

①内部ＲＡＭのアドレッシングの際に必要となる「プレバイト」を、アセンブラがソースプログラムを解釈して自動的に生成する”プレバイト自動生成機能”を装備。もちろん他のアセンブラソースとの互換をとるためにこれを無効にすることも可能。
②ＬＯＣＡＬ、ＥＮＤＬ疑似命令を用いることにより１６段までネスト可能な「ローカル・ラベル」が使用できるので、”意味のある”ラベル名を付けることが容易。
③引数付きファイル・インクルード命令「ＩＮＣＬＵＤＥ」を使うことにより、マクロ展開ライクなソースの記述が可能。ファイルのインクルードは何段でも可能。
④エラー発生時のリスティング・ファイルはＭＩＦＥＳ等のエディタでタグ・ファイルとして使用できる。
⑤オプションの指定により５種類のオブジェクトを出力可能。
⑥別途発表の「ポケット・リンクシステム」と併用することにより、生成されたオブジェクトを非常に簡単に、しかも高速にポケコンに転送してテストすることが可能なシステムを構成することができる。

　－２．　ソース・プログラムの記述方法－
　ソース・プログラムは以下の書式に従って書かれている必要があります。

　－２．１　ファイルの仕様－
　１行１ステートメントから成り、最終ステートメントはＥＮＤ疑似命令で終了している必要があります。

　－２．２　ステートメントの仕様－
　各ステートメントは以下の構文図を満足している必要があります。

　　-statement- 

　　+--------------------->-----------------------+ 
　　| 　　　　　　　　　　　　　　　　　　　      | 
　--+->- [label] ->- ":" ->-+->- [instruction] ->-+->- [comment] --+--
　　| 　　　　　　  　　　  | 　　　　　　　　    | 　　　　　　　 |
　　+->- [space] ----->-----+----------->---------+------->--------+  

　　-instruction- 
　　　　　　　　　　  +------------->-----------+ 
　　　　　　　　　　  | 　　　　　  　　　　    | 
　-->-- [mnimonic] ->-+->-+->- [operand] ->-+->-+->-
　　　                    | 　　　　　　    | 
　　　                    +---<---","---<---+ 

　　-mnimonic-

　-->--+------->-------+->- mnimonic ->-+-------->------+->-
　　　 |　　　　　　　 |　　　　　　　　| 　　　　　　　| 
　　　 +->- [space] ->-+　　　　　　　  +->- [space] ->-+ 

　　-operand- 

　-->--+------->-------+->-  operand ->-+-------->------+->-
　　　 |　　　　　　　 |　　　　　　　　| 　　　　　　　| 
　　　 +->- [space] ->-+　　　　　　　  +->- [space] ->-+ 

　　-space- 

　-->--+->- " " or TAB ->-+->-  
　　　 |　　　　　　　　　| 
　　　 +---------<--------+ 


　　-comment- 

　-->- ";" ->-+---->----+->-
　　　　　　　| 　　　  | 　　　　... ? is a one-character wild card
　　　　　　　+-<- ? -<-+ 

　－２．３　ラベルの仕様－
　ラベルを構成する文字にはａ～ｚ，Ａ～Ｚ，０～９，「＿（アンダースコア）」が使用できますが、大文字小文字は同一の物として処理されます。またラベル開始文字に０～９を使用することは出来ません。
　ラベルの長さは最大１６文字までです。１６文字を越えるとエラーになります。
　予約語と同一名のラベルも作成でき、原則として参照も可能ですが、命令によっては参照できないものもあります。ですからそのようなラベルの使用は出来るだけ避けるほうが賢明です。
　ラベルの再定義はできません。

　－２．４　オペランドの仕様－
　オペランドには数字、文字定数、ラベル、ロケーション・カウンタ、インクルード引数を使用することができ（一部の疑似命令ではファイル名も）、それらを演算子を用いて演算することも出来ます。数値は式の途中でも逐次２０bitsの符号なし整数に変換され、命令の要求するバイト数だけ下位から参照されます。

●数字
　０～９，ａ～ｆ，Ａ～Ｆが使用できます。ただし数字構成文字の先頭は０～９または「＄」（１６進数値の場合のみ）でなくてはなりません。
　デフォルトは１０進数ですが、最後尾に特定の文字を付けることにより基数を変えることが出来ます。ただしｎ進数の場合、構成文字が（ｎ－１）を越えてはなりません。
　最後尾文字と基数の関係は以下の通りです。
　　Ｂ，ｂ・・・２進
　　Ｏ，ｏ・・・８進
　　Ｄ，ｄ・・・１０進
　　Ｈ，ｈ・・・１６進
　また、桁が多くなった場合に見易くするため、「＿（アンダー・スコア）」を任意の位置に挿入することが出来ます。

　（例）　０１００＿１１００ｂ・・・＄４Ｃ

●文字定数
　「’（シングル・クォート）」で囲まれた中の文字のうち、右の「’」に一番近い１文字の文字コードが数値として扱われます。ヌル・コードは「’’」、シングル・クォート自身はシングル・クォートを２つ連続して書くことにより記述できます。

　（例）　’ＡＢＣＤ’・・・＄４４（「Ｄ」のコード）
　　　　　’’’’　　・・・＄２７（シングル・クォートのコード）
　　　　　’　’　　　・・・＄２０（スペースのコード）
　　　　　’’　　　　・・・＄００（ヌル・コード）

●ロケーション・カウンタ
　ロケーション・カウンタ（ＬＣ）は「＊」で表され、現在アセンブル中の命令が置かれるべきアドレスを値として持ちます。なおロケーションカウンタと乗算記号は同じ「＊」を用いていますが、式評価ルーチンは文脈判断を行なっているので、両者を混同しても正しく評価します。

　（例）　－１＊－＊＋＊・・・「マイナス１かけるマイナスＬＣたすＬＣ」と評価

●インクルード引数
　被インクルードファイル中に限り、「＠（アットマーク）」の後に０～９の数字を付けることによりＩＮＣＬＵＤＥ疑似命令で渡された引数を参照することが出来ます。
　第１引数は「＠０」に対応し、以下「＠１」、「＠２」・・・はそれぞれ第２引数、第３引数・・・となります。
　現在アセンブル中のファイルが被インクルードファイルでなかったり、ＩＮＣＬＵＤＥ疑似命令に引数が無かったり、また渡された個数以上の引数を参照するとエラーになります。

●演算子
　演算子には「｜（論理和）」、「＆（論理積）」、「％（剰余）」、「＋（加算）」、「－（減算）」、「＊（乗算）」、「／（除算）」が使用でき、優先順位は

　　「｜」　＜　「＆」　＜　「％」　＜　「＋」，「－」　＜　「＊」，「／」

の順です。また優先順位の変更には「（」、「）」が使用できますが、右括弧と左括弧の対応が取れていなくてはなりません。
　「＋」、「－」は式の先頭または演算子の後に付いた場合、符号を意味し、最優先で処理されます。

　－２．５　命令について－
　ＳＣ６２０１５の持つ全命令をアセンブルできます。なお「ｍｖ　ａ，ｘ」のように、純正命令表では禁止されているが実際は使用可能な命令もアセンブルできるようになっていますので、今後ＣＰＵの設計変更等の情報があった場合には命令関係の情報に十分注意してください。
　ＰＵＳＨＳ　ｒやＰＯＰＳ　ｒは等価なｍｖ命令で展開されます。
　アセンブルを制御するために使用できる疑似命令は以下の通りです。なお、書式中の［・・・］は・・・が省略可能であることを、［・・・］＊は・・・が０回以上繰り返されることを示しています。

●ＯＲＧ
書式：ORG operand 
　・・・次から展開されるオブジェクトの先頭アドレスを決定します。アセンブルされた時点でoperand が未定義だとエラーになるので注意が必要です。また、一連のソースプログラム中で２回以上ＯＲＧが出現した場合はその値によって次のように処理されます。
　＞過去のアドレスに設定しようとした場合・・・エラーになります。
　＞未来のアドレスに設定しようとした場合・・・ロケーション・カウンタを強制的に書き替えるために警告（warning ）が発生します。

●ＥＮＤ
書式：END 
　・・・ソースプログラムの終わり、またはインクルードファイルの終わりを示します。この命令がアセンブルされた時点でＬＯＣＡＬとＥＮＤＬとの対応が取れていないとエラーになります。

●ＥＱＵ
書式：label: EQU operand
　・・・ラベルに値を代入します。アセンブルされた時点でoperand が未決定であってもアセンブル終了までに何らかの形で決定されればエラーになりません。但し、ラベル定義が循環していたり、矛盾するラベル定義はエラーになります。

　（例）　lable1: EQU label2　｢ﾎ｢label1もlabel2も決定しないのでエラー
　　　　　label2: EQU label1　｢ｺ
　　　　　label3: EQU label3+2｢｢｢矛盾する定義はエラー

　また、先頭のlabel が無い場合もエラーになります。

●ＤＢ，ＤＭ
書式：DB(DM) operand [,operand ]* 
　・・・operand のうち、下位１バイトを展開します。オペランドは「，（カンマ）」で区切ることにより複数個記述できます。また、ＤＢ，ＤＭ，ＤＷ，ＤＰのオペランド中においてのみ次の書式が有効です。
　書式：’ｃ・・・ｃ’
　機能：「’」で囲まれた間の文字列を１バイト毎の文字コードとして展開する。「’」自身は「’」を２つ連続して書くことにより記述できます。

　（例）　'I don''t know' 
　　　　　  ・・・$49,$20,$64,$6F,$6E,$27,$74,$20,$6B,$6E,$6F,$77 と展開

●ＤＷ
書式：DW operand [ ,operand ]*
　・・・operand のうち、下位２バイトを下位、上位の順に展開します。その他についてはＤＢ，ＤＭに準じます。

●ＤＰ
書式：DP operand [ ,operand ]*
　・・・operand を下位、中位、上位（４bits) の順に３バイトにわたり展開します。上位１バイトのうち上位４bitsは常に０です。その他についてはＤＢ，ＤＭに準じます。

●ＤＳ
書式：DS operand1 [ ,operand2 ] 
　・・・operand1で示されたバイト数を確保します。operand2も存在するときは確保したメモリ領域をoperand2のうちの下位１バイトで埋めます。

●ＰＲＥ
書式：PRE operand 
　・・・operand で示される値をプレバイトそのものとみなして１バイト展開します。但しoperand は＄２１以上＄２７以下、または＄３０以上＄３７以下でなければエラーになります。またプレバイト自動生成機能が有効なときにこの命令を使用すると警告が発生します。

●ＰＲＥ＿ＯＮ
書式：PRE_ON
　・・・以降のソースプログラムに対してプレバイト自動生成機能を有効にします。デフォルトはＰＲＥ＿ＯＦＦの状態です。

●ＰＲＥ＿ＯＦＦ
書式：PRE_OFF 
　・・・以降のソースプログラムに対してプレバイト自動生成機能を無効にします。

●ＬＯＣＡＬ
書式：label: LOCAL
　・・・label をエントリ・ラベルとして以降、ＥＮＤＬまでをローカル・ブロックと宣言します。ローカル・ブロック中で更にローカル・ブロックを宣言するなどのネスティングも可能です。ただし、label が存在しないときはエラーになります。詳しくは後述の「階層化ラベルについて」を参照してください。

●ＥＮＤＬ
書式：ENDL
　・・・ローカル・ブロックの終了を宣言します。先にローカル・ブロックが宣言されていないときにはエラーになります。

●ＩＮＣＬＵＤＥ
書式：INCLUDE filename [ ,argument ]* 
　・・・この命令がアセンブルされると、filenameで指定されたファイルをopenしてそのファイルをアセンブル対象とします。ファイルが終了すれば元のファイルの続きからアセンブルを再開します。被インクルード・ファイル中から更にＩＮＣＬＵＤＥ命令を使うなどのネスティングも可能です。
　また、filenameの後にargumentが存在する場合はそれらを引数として被インクルード・ファイルに渡すことができ、被インクルード・ファイル中ではそれらを「＠０」～「＠９」として参照できます。但し、argumentは最大１０個までしか許されません。

　－３．　アセンブル方法－
　アセンブルを行なうには
　　A>XASM filename[.ext] 
とします。filenameを省略した場合は簡単なガイダンスが表示されコマンドレベルに戻ります。またソース・ファイル名のエクステンションが”．ＡＳＭ”である場合にはエクステンションを省略しても構いません。
　アセンブルが開始されると[ PASS1 ] 、[ PASS2 ] と現在の処理段階が表示され、正常にアセンブルが終了した場合にはオブジェクトのスタート・アドレスとエンド・アドレス、オブジェクト・サイズが表示されてコマンドレベルに戻ります。なお、ＥＱＵ命令で定義されるラベルが定義される前に参照されるような場合は[ PASS1 ] と[ PASS2 ] の間にラベル定義のためのパス（[ EQU define ]）が入ります。
　アセンブル途中でエラーが発生した場合には、ディスプレー上にエラーの発生したファイル名とエラーの発生した行番号、エラーの種類が表示されます。またリスティング・ファイルの出力指定がある場合にはリスティング・ファイルにも同じ情報が出力されます。

　ところで、ＸＡＳＭは単に　XASM filename とするだけではアセンブルをするだけでファイルとしては何も出力してくれません。オブジェクト・ファイルを出力させたりリスティング・ファイルを出力するためにはそれなりのオプションを指定する必要があります。

　ＸＡＳＭに用意されているオプションは次の通りです。

●Ｌ
書式：L[filename] 
　・・・リスティング・ファイルを出力するように指定します。filenameが指定されないときはソース・ファイルのプライマリにエクステンション、”．ＬＳＴ”が付加されたものになります。

●Ｅ
書式：E 
　・・・リスティング・ファイル中のオブジェクト部を抑圧して、エラー部のみを残すように指定します。ＰＡＳＳ２の段階でエラーが発生しそうであり、かつリスティング・ファイルをエディタのタグ・ファイルとして利用したい場合はＬオプションと同時にこのオプションも指定すると良いでしょう。なお、Ｌオプションが指定されていない場合は無効になります。

●Ｏ
書式：O[filename] 
　・・・オブジェクト・ファイルを出力するように指定します。filenameが指定されないときはソース・ファイルのプライマリにエクステンション、”．ＯＢＪ”が付加されたものになります。

●Ｓ
書式：S 
　・・・リスティング・ファイルの最後尾に使用したラベルとその値の一覧表を付加するように指定します。ただしＬオプションが指定されていないと無効になります。

●Ｃ
書式：C 
　・・・アセンブル途中に現在処理中の行番号をディスプレーに表示するように指定します。長いファイルなどをアセンブル中で、どこまで処理が終わったかが気になる場合に指定するといいかも知れません。

●Ｔ
書式：T[object type]
　オブジェクト・ファイルのフォーマットを指定します。object type とフォーマットの対応は以下の通りです。

　object type 　フォーマット
　　　Z 　　　　ＺＳＨ形式のオブジェクトを指定します。
　　　F 　　　　ＦＴＸ形式のオブジェクトを指定します。
　　　B 　　　　バイナリ・データ形式のオブジェクトを指定します。バイナリ・データ　　　　　　　　形式とは
　　　　　　　　 object_size(3bytes)+start_address(3bytes)+object_body(n bytes) 　　　　　　　　からなる物を指します。
　　　H 　　　　ヘキサデシマル形式のオブジェクトを指定します。ヘキサデシマル形式　　　　　　　　とは、バイナリデータ形式のデータを１６進２桁２バイトのキャラクタ　　　　　　　　に変換し、６４文字毎に改行コードを挿入したものです。
　　other 　　　オブジェクト本体の前に、ポケコンのＩＯＣＳがマシン語ファイルとし　　　　　　　　て扱うために必要な情報が含まれたヘッダ（１６バイト）を付加したタ　　　　　　　　イプのオブジェクトを指定します。

　オブジェクトタイプを指定しなかった場合には自動的にother が指定されます。

●Ｗ
書式：W 
　・・・警告を発生するように指定します。

　オプションを使用するためには
　　A>XASM filename -option [-option]*
　とすればＯＫです。オプション名は大文字小文字どちらでも同等に扱われます。

　　（例）A>XASM TEST -L -OTEST1.FTX  -S -TF -W 
　　　　　　　・・・TEST.LSTという名前でリスティング・ファイルを作成し、TEST1.FT　　　　　　　　　　X という名前でオブジェクト・ファイルを作成し、シンボルリスト　　　　　　　　　　を作成し、オブジェクト形式をＦＴＸ形式に指定し、警告も発生す　　　　　　　　　　るように指定する。

　－４．　階層化ラベルについて－
　ＣＰ／ＭからＭＳ－ＤＯＳに移ったとき、何が嬉しかったかと言えば、一番は何といっても階層化ディレクトリだったのではないでしょうか？
　いままで全部rootに置くしかなくて整理がつかなかったのが、各関連項目別にディレクトリを作ってそこに放り込むことですっきりと整理できるようになったからです。それにディレクトリの中に更にサブ・ディレクトリを作ったりでき、ディレクトリが違えば同一名のファイルが同じディスク上に存在できるなど、階層化ディレクトリの提供する環境は大変便利なものです。
　ところで、現在のアブソリュート・アセンブラのラベル管理を考えてみてください。
　アセンブラのソースを書くうえで何に一番頭を使っているかと言えば「ラベルの名前付け」ではないでしょうか？
　分岐命令にはラベルがつきものです。１つ小さなループを作るにも最低１つのラベルを使わなくてはなりません。その度に「え～、label09 はもう使ったから次はlabel0a か？」と、本来の目的とは全く違うところで無駄な労力を使わなくてはなりません。しかも後から見たときコメントでも書いてなくてはlabel09 が何を意味するのか、label0a が何を意味するのか、全くわかりません。
　そこでこのような「ラベルの名前付け問題」から頭を開放するために今回は実験的に、「階層化ラベル」という概念を取り入れてみました。考え方はＵＮＩＸ、ＭＳ－ＤＯＳの階層化ファイル構造とよく似ていますから容易に理解できるものと思います。

　まず、サブ・ディレクトリに当たるものですが、当アセンブラシステムではこれをローカル・ブロック（Local block ）と呼んでいます。ローカル・ブロックを定義するには「ＬＯＣＡＬ」と「ＥＮＤＬ」という疑似命令をペアで使用するだけでＯＫです。
　例えばサンプルの２行目から６行目を見てください。このようにすれば、ＬＯＣＡＬからＥＮＤＬまでの間が「ＡＢＣ」という名前のローカル・ブロックになります。
　またローカル・ブロックのなかに更にローカル・ブロックを作ることも出来ますからサンプルの７行目から２０行目のような書き方も可能です。
　ローカル・ブロックの中はサブ・ディレクトリと同じようなものですから、ブロックの外に同一名のラベルがあっても構いません（サンプルの２行目と１２行目）。そこでローカル・ブロック内のラベルをローカル・ラベルと呼ぶことにします。
　さて、ローカル・ブロックやローカル・ラベルが出来てもオペランドでそれが指定できなくては何の意味もありませんね。
　そこで今度はラベルの指定方法ですが、これはＵＮＩＸやＭＳ－ＤＯＳのそれと非常に似ています。書式は以下の通りです。

①同一ブロック内のラベルはラベル名だけで良い（サンプルの５行目）。
②自分の居るブロックの中にあるローカル・ブロックの中のラベルを指定するときは
　　［　ブロック名　！］＊　ラベル名
とする（サンプルの９行目）。
③自分の居るブロックの外のラベルを指定するには
　　．．！ラベル名
とする（サンプルの１４行目）。なお「．．」だと１つ外（＝すぐ外）になるが、「．．．」で２つ外、「．．．．」で３つ外・・・という具合になる。
④一番外のブロックから順にたどっていくときは
　　！［　ブロック名　！］＊　ラベル名
とする（サンプルの１１行目）。
⑤自分の居るブロックとは違うブロック内のラベルを相対的に指定するには
　　．［．］＊　！［　ブロック名　！］＊　ラベル名
とする（サンプルの２５行目）。また、④のように直接指定しても良い。
------------------------------------------------------------------------------
　-SAMPLE.ASM-
        org     $bf800　　　　　　　　　;1
abc:    local 　　　　　　　　　　　　　;2
        mv      a,0 　　　　　　　　　　;3
l1:     inc     a 　　　　　　　　　　　;4
        jrnz    l1　　　　　　　　　　　;5
        endl　　　　　　　　　　　　　　;6
def:    local 　　　　　　　　　　　　　;7
        mv      a,0 　　　　　　　　　　;8
        callf   abc!l2　　　　　　　　　;9
l3:     add     ($10),a 　　　　　　　　;10 
        jpf     !ghi!abc!abc!l4 　　　　;11 
abc:    local 　　　　　　　　　　　　　;12 
        mv      a,0 　　　　　　　　　　;13 
        mv      x,..!l3 　　　　　　　　;14 
        add     ($10),a 　　　　　　　　;15 
l2:     retf　　　　　　　　　　　　　　;16 
l5:     nop 　　　　　　　　　　　　　　;17 
        endl　　　　　　　　　　　　　　;18 
        nop 　　　　　　　　　　　　　　;19 
        endl　　　　　　　　　　　　　　;20 
ghi:    local 　　　　　　　　　　　　　;21 
abc:    local 　　　　　　　　　　　　　;22 
abc:    local 　　　　　　　　　　　　　;23 
l4:     nop 　　　　　　　　　　　　　　;24 
        mv      x,....!def!abc!l5 　　　;25 
        endl　　　　　　　　　　　　　　;26 
        endl　　　　　　　　　　　　　　;27 
        endl　　　　　　　　　　　　　　;28 
        end 　　　　　　　　　　　　　　;29 

　-SAMPLE.LST-
0BF800                          org     $bf800
0BF800                   abc:   local 
0BF800 08 00                    mv      a,0 
0BF802 6C 00             l1:    inc     a 
0BF804 1B 04                    jrnz    l1
0BF806                          endl
0BF806                   def:   local 
0BF806 08 00                    mv      a,0 
0BF808 05 1A F8 0B              callf   abc!l2
0BF80C 43 10             l3:    add     ($10),a 
0BF80E 03 1D F8 0B              jpf     !ghi!abc!abc!l4 
0BF812                   abc:   local 
0BF812 08 00                    mv      a,0 
0BF814 0C 0C F8 0B              mv      x,..!l3 
0BF818 43 10                    add     ($10),a 
0BF81A 07                l2:    retf
0BF81B 00                l5:    nop 
0BF81C                          endl
0BF81C 00                       nop 
0BF81D                          endl
0BF81D                   ghi:   local 
0BF81D                   abc:   local 
0BF81D                   abc:   local 
0BF81D 00                l4:    nop 
0BF81E 0C 1B F8 0B              mv      x,....!def!abc!l5 
0BF822                          endl
0BF822                          endl
0BF822                          endl
0BF822                          end 

 - Symbols -

0BF800 : ABC
0BF802 : ABC ! L1 
0BF806 : DEF
0BF80C : DEF ! L3 
0BF812 : DEF ! ABC
0BF81A : DEF ! ABC ! L2 
0BF81B : DEF ! ABC ! L5 
0BF81D : GHI
0BF81D : GHI ! ABC
0BF81D : GHI ! ABC ! ABC
0BF81D : GHI ! ABC ! ABC ! L4 

  No fatal error.  Code: 0BF800h - 0BF821h [       34 byte(s)]
------------------------------------------------------------------------------
　上記ではブロック名とラベル名を分けて書いてありますが内部では両者を区別していませんので、ラベルのつもりでブロック名をオペランドに使用することも全く構いません。

　以上が階層化ラベルの概要と使い方ですが、考え付いてまだ日が浅いので多少使いにくい点があるかも知れません。しかし、ソース・プログラムを機能分化して書いたり、ＩＮＣＬＵＤＥ疑似命令を使ったライブラリ・ライクなプログラミングをする際にはきっと役に立つのではないかと思いますので、有効に活用してやってください。

　－５．　エラーと警告の一覧表　－
　ＸＡＳＭはアセンブル中、ソース・コードに不備な点を発見するとエラーまたは警告を発します。以下はそのエラー＆警告メッセージの一覧とその内容を示したものです。

　－５．１　ソース・コードに関するエラー　－
●Prebyte error 
　・・・プレバイトの指定がおかしい（mv (bp+py),0  など）
●Division by zero
  ・・・０で割ろうとした
●Operator error
　・・・演算子として適当でない記号、または期待されていない演算子が存在する
●Unevaluetable operand 
　・・・オペランドの書式がおかしいので評価できない
●Bad internal RAM addressing 
　・・・内部ＲＡＭの表現または参照方法がおかしい
●Bad external MEMORY addressing
　・・・外部メモリの表現または参照方法がおかしい
●Undefined instruction 
　・・・存在しない命令や存在しないオペランドの組合せを実行しようとした
●Bad separator 
　・・・区切り記号として適当でない記号を用いているか、必要な区切り記号がない
●Branch too far
　・・・分岐先が遠すぎて相対分岐命令では分岐できない
●Label format error
　・・・ラベルとしては書式がおかしい
●Label not found 
　・・・指定されたラベルは未定義である
●Duplicate label 
　・・・同一ブロック内で同一名のラベルを２つ以上定義しようとした
●"LOCAL" not closed
　・・・ＬＯＣＡＬに対応するＥＮＤＬが存在しない
●No label before EQU 
　・・・同一ステートメント内でＥＱＵの前にラベルが存在しない
●LOCAL nesting too deep
　・・・ＬＯＣＡＬのネストが深すぎる（最高１６段まで）
●ENDL used without LOCAL 
　・・・ＥＮＤＬに対応するＬＯＣＡＬが存在しない
●EOF comes before END
　・・・ＥＮＤが来る前にファイルが終了してしまった
●' unmatch 
　・・・「’（シングル・クォート）」の対応関係がおかしい
●No label before LOCAL 
　・・・同一ステートメント内でＬＯＣＡＬの前にラベルが存在しない
●Missing operand 
　・・・必要なオペランドが存在しない
●Missing operator
　・・・必要な演算子が存在しない
●Numeric format error
  ・・・数値表現がおかしい
●Missing numeric 
　・・・必要な数値が存在しない
●Too complex operand 
　・・・オペランドの式表現が複雑すぎる
●Location counter wandered 
　・・・ロケーション・カウンタの値が不定になった
●EQU undefinable(suspicious label is "xxxxxx") 
　・・・ラベル定義が循環しているか矛盾したラベル定義を行なおうとした。原因として疑わしいラベルはxxxxxxである
●Too many arguments
　・・・ＩＮＣＬＵＤＥにおいて引数の個数が多すぎる（最大１０個）
●Bad argument number 
　・・・定義されていないＩＮＣＬＵＤＥ引数を参照しようとした

　－５．２　ソース・コードに関する警告　－
●Warning: Location counter already set 
　・・・ロケーション・カウンタを再定義することによってオブジェクトのアドレスに矛盾を生じる危険性があるという警告
●Warning: Used PRE while auto-prebyte is active
　・・・プレバイト自動生成機能が有効であるにも関わらず無駄なプレバイトを生成しようとしたことに対する警告
●Warning: No effective code
　・・・アセンブルしてもオブジェクトに何の影響を与えない命令が存在することに対する警告
●Warning: LOCAL and ENDL not match in included file
　・・・ライブラリ化されたソース・コードを想定した場合、被インクルード・ファイル内でローカル・ブロックが閉じていない、不完全な構造であることに対する警告

　－５．３　ファイル入出力に関するエラー　－
●Source file not found 
　・・・ソース・ファイルが見つからない
●Source file not open
　・・・指定のソースファイルをオープンすることができない
●Output file not open
　・・・出力目的のファイルをオープンすることができない
●Operation not allowed on a logical device 
　・・・論理デバイスへの不当なアクセスを行なおうとした
●Assign to STD files not allowed 
　・・・標準デバイスへのアサインはできない
●Unexpected EOF
　・・・予期せずしてファイルが物理的終了に来てしまった
●Disk write error
　・・・何らかの原因によってファイルへの出力が不可能になった
●Directory is full 
　・・・必要なディレクトリを確保できない
●File size overflow
　・・・ファイルサイズが大きすぎる
●Too many open files 
　・・・オープンしているファイルが多すぎる
●File disappeared
　・・・ファイルが消滅してしまった
●Some error happend
　・・・上記以外の入出力エラー

　－６．　使用上の注意－
●再帰的なＩＮＣＬＵＤＥ命令の使用はチェックしていないので、そのようなソース・コードを記述してアセンブルすると「Too many open files 」の入出力エラーが出てアセンブルを中止します。
●ＥＱＵ命令の前であってもラベルの後の「：（コロン）」は省略できません。これについては様々な意見があるかと思いますが、私は敢えてコロンを取る必要はないと考えたため、このような仕様にしました。
●ＯＲＧ命令でロケーション・カウンタの値を再設定すると、オブジェクトの置かれるアドレスとジャンプ命令等のオペランドの間に矛盾を生じる可能性があります。ロケーション・カウンタの再設定はラベル定義の都合上、止むを得ない場合のみにしておいたほうが安全です。再設定した後、何らかのオブジェクトを吐く場合にはＯＲＧ命令の代わりにＤＳ命令を使用すべきです。

　（例）　ORG $BF000　-> DS $BF000-*

　ただしＤＳ命令はオペランドが大きい数の場合、アセンブルに非常に時間がかかりますのでご注意ください。
●相対分岐命令ではオペランドとローケション・カウンタの値からアセンブラが判断して自動的に適切な命令を展開しますので、分岐方向を考える必要はありません。
●オペランドを記述する際に不要な括弧を付けると、命令によってはアセンブラが内部ＲＡＭアドレッシングと勘違いし「Undefined instruction 」を発してアセンブルを中断してしまうことがあります。不要な括弧は付けないでください。

　（例）誤：ADD ($10),($20) 　・・・エラーになる
　　　　正：ADD ($10),$20 　　・・・正常にアセンブルされる

●アセンブル中、オペランドにその時点では未定義であってかつ未来においてＥＱＵ命令によって定義されるラベルがある場合にはラベル定義のためにパスが１つ増え、その分アセンブル終了までに時間がかかります。したがって、出来るだけＥＱＵ命令はそのラベルがオペランドで参照される前に使用したほうが賢明です。
　もちろん定義が循環している場合や矛盾する定義はエラーになります。
●文字定数はＤＷ，ＤＰ命令中であっても１文字１バイトで展開されます。
●アセンブルを正常に終了した場合はＭＳ－ＤＯＳの「ＥＲＲＯＲＬＥＶＥＬ」に０を返し、エラーが発生したときは１を返しますのでバッチ・プログラミングをする際に利用すると便利かも知れません。

　－７．　How do you feel about "XASM" ?－
　ＸＡＳＭの使い勝手はいかがなものでしょうか？
　制作に１ヵ月、改良に３ヵ月以上の期間と、直接またはＢＢＳを通じて多くの方に助言を頂きながら作り上げてきたものなので、アセンブル速度の面を除いてはかなり満足のいく設計になっていると思います。
　最後に、リスティング・ファイルをエディタのタグ・ファイル形式にすることを提案して下さった石岡尚氏、開発段階においてバグ発見＆サンプルプログラム作成に協力して下さったE.Kako氏、JA1YAD各局、他、助言を下さったすべての方に対し、この場を借りて厚くお礼を申し上げます。
